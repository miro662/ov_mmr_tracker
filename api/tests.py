from django.test import TestCase
from django.contrib.auth.models import User
from rest_framework.serializers import DateTimeField
from rest_framework.test import APIRequestFactory, APIClient, force_authenticate
from rest_framework import status

from characters.models import Character
from matches.models import Match
from .serializers import CharacterSerializer, MatchSerializer
from .permissions import IsMatchOwner

class TestCharacterSerializer(TestCase):
    def setUp(self):
        self.character = Character(name='Test', role=Character.DAMAGE)
        self.character.save()

    def testSerializingCharacter(self):
        """
        Test if character serialization works correctly
        """
        expected_data = {
            'id': self.character.id,
            'name': self.character.name,
            'role': self.character.role
        }

        serializer = CharacterSerializer(self.character)
        self.assertEqual(
            expected_data,
            serializer.data,
            'Serializer should return data in expected format'
        )

    def testDeserializingCharacter(self):
        """
        Test if character deserialization works correctly
        """
        newData = {
            'name': 'New character',
            'role': Character.TANK
        }
        serializer = CharacterSerializer(data=newData)
        self.assertTrue(
            serializer.is_valid(),
            'Serialization of correct data is valid'
        )
        self.assertEqual(
            serializer.validated_data['name'],
            newData['name'],
            'Serialized data should have the same character name as in data'
        )
        self.assertEqual(
            serializer.validated_data['role'],
            newData['role'],
            'Serialized data should have the same role as in data'
        )


class TestMatchSerializer(TestCase):
    def setUp(self):
        self.characters = [
            Character(name='Test1', role=Character.DAMAGE),
            Character(name='Test2', role=Character.DAMAGE)
        ]
        for c in self.characters:
            c.save()

        self.user = User.objects.create_user('testuser')

        self.match = Match(user=self.user, mmr_after=1000)
        self.match.save()
        self.match.characters.set(self.characters)
    
    def testSerializingMatch(self):
        # Test if match serialization works correctly
        expected_data = {
            'id': self.match.id,
            'characters': [c.id for c in self.match.characters.all()],
            'date': DateTimeField().to_representation(self.match.date),
            'mmr_after': self.match.mmr_after
        }
        serializer = MatchSerializer(self.match)
        self.assertEqual(
            expected_data,
            serializer.data,
            'Serializer should return data in expected format'
        )


class TestIsOwnerPermission(TestCase):
    def setUp(self):
        self.character = Character(name='Test', role=Character.DAMAGE)
        self.character.save()

        self.owner = User.objects.create_user('owner')
        self.notOwner = User.objects.create_user('notowner')

        self.match = Match(user=self.owner, mmr_after=1000)
        self.match.save()
        self.match.characters.set([self.character])

        self.permission = IsMatchOwner()

    def testPermissionGrantedToOwner(self):
        """
        If user currently logged in is owner of match, permission should
        be granted, both for safe (GET) and unsafe (e. g. POST) methods
        """
        factory = APIRequestFactory()
        get_request = factory.get('/path_does_not_matter_here/')
        force_authenticate(get_request, user=self.owner)
        get_request.user = self.owner # there is no .user in request generated by APIRequestFactory
        self.assertTrue(
            self.permission.has_object_permission(get_request, None, self.match),
            'Permission should be granted for GET request with user which is match owner'
        )

        post_request = factory.post('/path_does_not_matter_here/')
        force_authenticate(post_request, user=self.owner)
        post_request.user = self.owner # there is no .user in request generated by APIRequestFactory
        self.assertTrue(
            self.permission.has_object_permission(post_request, None, self.match),
            'Permission should be granted for unsafe (e.g. POST) request with user which is match owner'
        )
    
    def testPermissionDeniedToNotOwner(self):
        """
        If user currently logged in is not owner of match, permission should
        be denied, both for safe (GET) and unsafe (e. g. POST) methods
        """
        factory = APIRequestFactory()
        get_request = factory.get('/path_does_not_matter_here/')
        force_authenticate(get_request, user=self.notOwner)
        get_request.user = self.notOwner # there is no .user in request generated by APIRequestFactory
        self.assertFalse(
            self.permission.has_object_permission(get_request, None, self.match),
            'Permission should be denied for GET request with user which is not match owner'
        )

        post_request = factory.post('/path_does_not_matter_here/')
        force_authenticate(post_request, user=self.notOwner)
        post_request.user = self.notOwner # there is no .user in request generated by APIRequestFactory
        self.assertFalse(
            self.permission.has_object_permission(post_request, None, self.match),
            'Permission should be denied for unsafe (e.g. POST) request with user which is not match owner'
        )


class TestMatchesViewset(TestCase):
    def setUp(self):
        self.character = Character(name='Test', role=Character.DAMAGE)
        self.character.save()

        self.owner = User.objects.create_user('owner')
        self.notOwner = User.objects.create_user('notowner')

        self.match = Match(user=self.owner, mmr_after=1000)
        self.match.save()
        self.match.characters.set([self.character])

        self.client = APIClient()
    
    API_MATCHES_LIST_URL = '/api/matches/'
    def testListsOnlyMatchesOfLoggedUser(self):
        """
        GET request to API_MATCHES_LIST_URL should return only matches of logged user
        """
        self.client.force_authenticate(user=self.owner)
        response = self.client.get(self.API_MATCHES_LIST_URL)
        self.assertEqual(
            status.HTTP_200_OK,
            response.status_code,
            'Request response code should be 200 (OK)'
        )
        self.assertEqual(
            1,
            len(response.data),
            'Response data should contain 1 object'
        )
        self.assertEqual(
            self.match.pk,
            response.data[0]['id'],
            'Object in response data should be match that belongs to user'
        )
        self.client.logout()

        self.client.force_authenticate(user=self.notOwner)
        response = self.client.get(self.API_MATCHES_LIST_URL)
        self.assertEqual(
            status.HTTP_200_OK,
            response.status_code,
            'Request response code should be 200 (OK)'
        )
        self.assertEqual(
            0,
            len(response.data),
            'Response data should contain 0 objects'
        )
        self.client.logout()

    API_MEW_MATCH_URL = API_MATCHES_LIST_URL
    def testCreatedMatchBelongsToCurrenltyLoggedInUser(self):
        """
        POST request to API_NEW_MATCH_URL should automatically assign User
        """
        data = {
            'characters': [self.character.pk],
            'mmr_after': 5000
        }
        self.client.force_authenticate(user=self.owner)
        response = self.client.post(self.API_MEW_MATCH_URL, data=data)
        self.assertEqual(
            status.HTTP_201_CREATED,
            response.status_code,
            'Request response code should be 201 (Created)'
        )
        new_match = Match.objects.get(id=response.data['id'])
        self.assertEqual(
            new_match.user,
            self.owner,
            'User field of recently created match should be assigned to currently logged user'
        )
        self.client.logout()
    